import type { SkippedBuildOutputPathFile } from "#utils/types/skipped-file";

export const buildOutputPathSkipReasons = [
  "minified extension",
  "bundled extension",
  "source map",
  "artifact directory",
  "test coverage report",
  "assets directory",
  "chunks directory",
  "third-party directory",
] as const;

/**
 * FAST CHECK: Run this BEFORE loading file content.
 * Checks file extensions and common directory patterns.
 */
export function isBuildOutputPath(
  filePath: string
): SkippedBuildOutputPathFile | undefined {
  // 1. Minified extensions (Standard)
  if (/\.min\.(js|css|html|json)$/i.test(filePath)) {
    const report: SkippedBuildOutputPathFile = {
      path: filePath,
      category: "build_output_path",
      reason: "minified extension",
    };
    return report;
  }

  // 2. Bundled extensions (Standard)
  if (/[.-]bundle\.(js|css)$/i.test(filePath)) {
    const report: SkippedBuildOutputPathFile = {
      path: filePath,
      category: "build_output_path",
      reason: "bundled extension",
    };
    return report;
  }

  // 3. Source maps (Standard)
  if (/\.map$/i.test(filePath)) {
    const report: SkippedBuildOutputPathFile = {
      path: filePath,
      category: "build_output_path",
      reason: "source map",
    };
    return report;
  }

  // 4. Artifact Directories
  // Safe to skip these as they usually contain compiled output.
  // Note: If malware is hidden in 'dist/', we rely on the package.json 'bin'/'main'
  // entry pointing to it to flag suspicious pointers, as we can't scan all dists.
  if (/^dist\//i.test(filePath) || /\/dist\//i.test(filePath)) {
    const report: SkippedBuildOutputPathFile = {
      path: filePath,
      category: "build_output_path",
      reason: "artifact directory",
    };
    return report;
  }
  if (/^build\//i.test(filePath) || /\/build\//i.test(filePath)) {
    const report: SkippedBuildOutputPathFile = {
      path: filePath,
      category: "build_output_path",
      reason: "artifact directory",
    };
    return report;
  }

  // "coverage" (Test coverage reports)
  if (/\/coverage\//i.test(filePath)) {
    const report: SkippedBuildOutputPathFile = {
      path: filePath,
      category: "build_output_path",
      reason: "test coverage report",
    };
    return report;
  }

  // "assets" folder is almost always hashed build output or static media
  if (/\/assets\//i.test(filePath)) {
    const report: SkippedBuildOutputPathFile = {
      path: filePath,
      category: "build_output_path",
      reason: "assets directory",
    };
    return report;
  }

  // "chunks" folder (Next.js / Webpack)
  if (/\/chunks\//i.test(filePath)) {
    const report: SkippedBuildOutputPathFile = {
      path: filePath,
      category: "build_output_path",
      reason: "chunks directory",
    };
    return report;
  }

  // "vendor" or "third_party"
  // We assume these are audited upstream.
  // Scanning them is usually too expensive/noisy.
  if (/\/vendor\//i.test(filePath) || /\/third_party\//i.test(filePath)) {
    const report: SkippedBuildOutputPathFile = {
      path: filePath,
      category: "build_output_path",
      reason: "third-party directory",
    };
    return report;
  }

  return undefined;
}

/**
 * SLOW CHECK: Run this AFTER loading file content.
 * Checks for signatures, line lengths, and density.
 */
export function isBuildOutputContent(content: string) {
  // 1. Webpack / Bundler Signatures
  if (content.includes("__webpack_require__")) {
    return { reason: "webpack_require" };
  }
  if (content.includes("webpackJsonp")) {
    return { reason: "webpackJsonp" };
  }

  // 2. Auto-generated Headers (Check first 1000 chars)
  // Expanded check to be safer
  const head = content.slice(0, 1000);
  if (/Generated by/i.test(head)) {
    return { reason: "generated_by" };
  }
  if (/Auto-generated/i.test(head)) {
    return { reason: "auto_generated" };
  }
  if (/DO NOT EDIT/i.test(head)) {
    return { reason: "do_not_edit" };
  }

  // 3. Line Length Heuristic (The "Golden Rule")
  // Catches minified code instantly.
  const MAX_LINE_LENGTH = 500;

  // Only check the first 20KB. If it's minified, we know by then.
  const CHECK_LIMIT_BYTES = 20_000;

  let currentLineLength = 0;
  const length = Math.min(content.length, CHECK_LIMIT_BYTES);

  for (let i = 0; i < length; i++) {
    const charCode = content.charCodeAt(i);
    // Newline check (LF: 10, CR: 13)
    if (charCode === 10 || charCode === 13) {
      currentLineLength = 0;
    } else {
      currentLineLength++;
    }

    if (currentLineLength > MAX_LINE_LENGTH) {
      return { reason: "line_length" };
    }
  }

  // 4. Line Count Limit (The "Monaco" Guardrail)
  // If a file is massive, it is likely vendored or generated.
  // It is also unreviewable by LLMs cost-effectively.
  const MAX_LINES = 3000;

  let lineCount = 0;
  // We can just iterate the string. JS engines optimize string iteration well.
  for (let i = 0; i < content.length; i++) {
    if (content[i] === "\n") {
      lineCount++;
      if (lineCount > MAX_LINES) {
        return { reason: "line_count" };
      }
    }
  }

  return { reason: "none" };
}
